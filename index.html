<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rainbow Wave Text Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Courier New", monospace;
        background: #1a1a1a;
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
      }

      .container {
        background: #2a2a2a;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        max-width: 800px;
        width: 100%;
      }

      h1 {
        text-align: center;
        margin-bottom: 20px;
        background: linear-gradient(
          90deg,
          #ff0000,
          #ff7f00,
          #ffff00,
          #00ff00,
          #0000ff,
          #4b0082,
          #9400d3
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .input-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
      }

      .sliders-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .slider-group {
        display: flex;
        flex-direction: column;
      }

      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .slider-value {
        background: #1a1a1a;
        padding: 4px 8px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 14px;
      }

      input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #1a1a1a;
        outline: none;
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer;
        border: none;
      }

      .file-info {
        background: #1a1a1a;
        padding: 8px 12px;
        border-radius: 3px;
        font-size: 12px;
        color: #aaa;
        margin-top: 8px;
      }

      input[type="text"] {
        width: 100%;
        padding: 12px;
        font-size: 18px;
        background: #1a1a1a;
        border: 2px solid #444;
        border-radius: 5px;
        color: #fff;
        font-family: "Courier New", monospace;
        box-sizing: border-box;
      }

      input[type="text"]:focus {
        outline: none;
        border-color: #ff7f00;
      }

      .canvas-container {
        background: #1a1a1a;
        border-radius: 5px;
        padding: 20px;
        margin: 20px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100px;
      }

      canvas {
        display: block;
        image-rendering: pixelated;
        border: 2px solid white;
      }

      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      button {
        flex: 1;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: transform 0.2s;
        min-width: 150px;
      }

      button:hover {
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background: #444;
        cursor: not-allowed;
        transform: none;
      }

      .status {
        text-align: center;
        margin-top: 10px;
        color: #aaa;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Rainbow Wave Text Generator</h1>

      <div class="input-group">
        <label for="textInput">Enter your text:</label>
        <input
          type="text"
          id="textInput"
          placeholder="ultrathink"
          value="ultrathink"
        />
      </div>

      <div class="sliders-container">
        <div class="slider-group">
          <div class="slider-label">
            <label for="framesSlider">Frames (smoothness)</label>
            <span class="slider-value" id="framesValue">100</span>
          </div>
          <input
            type="range"
            id="framesSlider"
            min="10"
            max="200"
            value="100"
            step="5"
          />
          <div class="file-info">More frames = smoother & larger file</div>
        </div>
        <div class="slider-group">
          <div class="slider-label">
            <label for="delaySlider">Delay (speed)</label>
            <span class="slider-value" id="delayValue">50ms</span>
          </div>
          <input
            type="range"
            id="delaySlider"
            min="0"
            max="200"
            value="50"
            step="5"
          />
          <div class="file-info">More delay = slower animation</div>
        </div>
      </div>

      <div class="sliders-container" style="margin-bottom: 15px">
        <div class="file-info" id="estimatedSize" style="display: flex; align-items: center; justify-content: center">
          Estimated size: ~<span id="sizeEstimate">50</span> KB
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px">
          <label style="font-weight: bold; font-size: 14px">Output Format</label>
          <div style="display: flex; gap: 15px">
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer">
              <input type="radio" name="format" value="gif" checked />
              GIF
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer">
              <input type="radio" name="format" value="apng" />
              APNG
            </label>
          </div>
          <div style="font-size: 11px; color: #888">
            APNG = 16M colors, GIF = 256 colors
          </div>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button id="downloadBtn">Download as <span id="formatType">GIF</span></button>
      </div>

      <div class="status" id="status"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.js"></script>
    <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.js"></script>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const textInput = document.getElementById("textInput");
      const downloadBtn = document.getElementById("downloadBtn");
      const status = document.getElementById("status");
      const framesSlider = document.getElementById("framesSlider");
      const delaySlider = document.getElementById("delaySlider");
      const framesValue = document.getElementById("framesValue");
      const delayValue = document.getElementById("delayValue");
      const sizeEstimate = document.getElementById("sizeEstimate");
      const formatType = document.getElementById("formatType");
      const formatRadios = document.querySelectorAll('input[name="format"]');

      let animationFrame;
      let frameCount = 0;
      let TOTAL_FRAMES = parseInt(framesSlider.value);
      let FRAME_DELAY = parseInt(delaySlider.value);
      let lastFrameTime = 0;

      function getColorAtPosition(position, waveOffset) {
        // Use HSL color space for smooth rainbow gradient
        // Hue cycles from 0-360 degrees around the color wheel
        const hue = (position * 20 - waveOffset + 360) % 360; // 20 degrees per character (~3 chars per color)
        const saturation = 100; // Full saturation for vibrant colors
        const lightness = 50; // Medium lightness for true rainbow colors

        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      }

      function drawText(text, frame = 0) {
        const fontSize = 24;
        ctx.font = `bold ${fontSize}px 'Courier New', monospace`;

        // Measure text to set canvas size
        const metrics = ctx.measureText(text);
        canvas.width = Math.ceil(metrics.width) + 20;
        canvas.height = fontSize + 10;

        // Redraw with correct size
        ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
        ctx.textBaseline = "top";

        // Fill with solid background to prevent flickering
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw each character with rainbow wave effect
        let x = 10;
        // Wave offset cycles through 360 degrees (full color wheel) over TOTAL_FRAMES
        const waveOffset = (frame / TOTAL_FRAMES) * 360;

        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const color = getColorAtPosition(i, waveOffset);

          ctx.fillStyle = color;
          ctx.fillText(char, x, 5);

          x += ctx.measureText(char).width;
        }
      }

      function animate(timestamp) {
        if (!lastFrameTime) lastFrameTime = timestamp;

        const elapsed = timestamp - lastFrameTime;

        if (elapsed >= FRAME_DELAY) {
          const text = textInput.value || "ultrathink";
          drawText(text, frameCount);
          frameCount = (frameCount + 1) % TOTAL_FRAMES;
          lastFrameTime = timestamp;
        }

        animationFrame = requestAnimationFrame(animate);
      }

      function startAnimation() {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
        frameCount = 0;
        lastFrameTime = 0;
        animate();
      }

      function updateEstimatedSize() {
        // Estimate based on typical GIF compression
        // Simple text GIFs: ~0.5-1 KB per frame depending on complexity
        const textLength = (textInput.value || "ultrathink").length;
        // Base size + per-character overhead
        const bytesPerFrame = 500 + textLength * 50;
        const estimatedBytes = TOTAL_FRAMES * bytesPerFrame;
        const estimatedKB = Math.round(estimatedBytes / 1024);
        sizeEstimate.textContent = estimatedKB;
      }

      textInput.addEventListener("input", () => {
        updateEstimatedSize();
        startAnimation();
      });

      framesSlider.addEventListener("input", (e) => {
        TOTAL_FRAMES = parseInt(e.target.value);
        framesValue.textContent = TOTAL_FRAMES;
        updateEstimatedSize();
        startAnimation();
      });

      delaySlider.addEventListener("input", (e) => {
        FRAME_DELAY = parseInt(e.target.value);
        delayValue.textContent = FRAME_DELAY + "ms";
        updateEstimatedSize();
        startAnimation();
      });

      formatRadios.forEach((radio) => {
        radio.addEventListener("change", (e) => {
          formatType.textContent = e.target.value === "apng" ? "APNG" : "GIF";
        });
      });

      downloadBtn.addEventListener("click", async () => {
        const text = textInput.value || "ultrathink";
        const format = document.querySelector('input[name="format"]:checked').value;

        if (!text.trim()) {
          status.textContent = "Please enter some text!";
          return;
        }

        downloadBtn.disabled = true;

        if (format === "apng") {
          await generateAPNG(text);
        } else {
          await generateGIF(text);
        }
      });

      async function generateGIF(text) {
        status.textContent = "Generating GIF...";

        // Step 1: Capture all frames as ImageData
        const frames = [];
        for (let i = 0; i < TOTAL_FRAMES; i++) {
          drawText(text, i);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          frames.push(imageData);
          status.textContent = `Capturing frames... ${i + 1}/${TOTAL_FRAMES}`;
          await new Promise((resolve) => setTimeout(resolve, 10));
        }

        status.textContent = "Building color palette...";
        await new Promise((resolve) => setTimeout(resolve, 10));

        // Step 2: Build optimal palette using RgbQuant
        const quantizer = new RgbQuant({
          colors: 256,
          minHueCols: 256, // Critical: Preserve all hues for rainbow gradients!
          dithKern: 'FloydSteinberg',
          dithSerp: true
        });

        // Sample all frames to build palette (pass ImageData directly)
        frames.forEach(imageData => {
          quantizer.sample(imageData);
        });

        status.textContent = "Quantizing frames...";
        await new Promise((resolve) => setTimeout(resolve, 10));

        // Get palette as RGB triplets
        const rgbPalette = quantizer.palette(true); // Returns [[r,g,b], [r,g,b], ...]

        // Convert palette to omggif format: (r << 16) | (g << 8) | b
        const omggifPalette = rgbPalette.map(rgb =>
          (rgb[0] << 16) | (rgb[1] << 8) | rgb[2]
        );

        // Reduce each frame to indexed colors
        const indexedFrames = frames.map((imageData, i) => {
          status.textContent = `Quantizing frame ${i + 1}/${TOTAL_FRAMES}`;
          return quantizer.reduce(imageData, 2); // 2 = indexed array
        });

        status.textContent = "Encoding GIF...";
        await new Promise((resolve) => setTimeout(resolve, 10));

        // Step 3: Encode with omggif
        // Calculate buffer size (rough estimate: width * height * frames + palette)
        const bufferSize = canvas.width * canvas.height * TOTAL_FRAMES + omggifPalette.length * 4 + 10240;
        const buffer = new Uint8Array(bufferSize);

        const gifWriter = new GifWriter(buffer, canvas.width, canvas.height, {
          palette: omggifPalette,
          loop: 0 // Infinite loop
        });

        // Add each frame
        indexedFrames.forEach((indexed, i) => {
          gifWriter.addFrame(0, 0, canvas.width, canvas.height, indexed, {
            delay: Math.round(FRAME_DELAY / 10), // omggif uses centiseconds (1/100s)
            disposal: 1 // Leave frame in place
          });
          status.textContent = `Encoding frame ${i + 1}/${TOTAL_FRAMES}`;
        });

        // Get final GIF data
        const gifData = buffer.subarray(0, gifWriter.end());
        const blob = new Blob([gifData], { type: "image/gif" });

        // Download the GIF
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${text.replace(/\s+/g, "-")}-rainbow.gif`;
        a.click();
        URL.revokeObjectURL(url);

        downloadBtn.disabled = false;
        status.textContent = "Download complete!";
        setTimeout(() => {
          status.textContent = "";
        }, 3000);

        // Resume animation
        startAnimation();
      }

      async function generateAPNG(text) {
        status.textContent = "Generating APNG...";

        const frames = [];
        const delays = [];

        // Capture all frames
        for (let i = 0; i < TOTAL_FRAMES; i++) {
          drawText(text, i);

          // Get image data from canvas
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          frames.push(imageData.data.buffer);
          delays.push(FRAME_DELAY);

          status.textContent = `Capturing frames... ${i + 1}/${TOTAL_FRAMES}`;
          await new Promise((resolve) => setTimeout(resolve, 10));
        }

        status.textContent = "Encoding APNG...";

        // Encode as APNG with UPNG library
        const apngBuffer = UPNG.encode(frames, canvas.width, canvas.height, 0, delays);
        const blob = new Blob([apngBuffer], { type: "image/png" });

        // Download
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${text.replace(/\s+/g, "-")}-rainbow.png`;
        a.click();
        URL.revokeObjectURL(url);

        downloadBtn.disabled = false;
        status.textContent = "Download complete!";
        setTimeout(() => {
          status.textContent = "";
        }, 3000);

        // Resume animation
        startAnimation();
      }

      // Start initial animation
      updateEstimatedSize();
      startAnimation();
    </script>
  </body>
</html>
